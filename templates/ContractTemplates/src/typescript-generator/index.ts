#!/usr/bin/env node

import * as fs from "fs";
import {
  CodeGeneratorRequest,
  CodeGeneratorResponse,
} from "google-protobuf/google/protobuf/compiler/plugin_pb";
import { FileDescriptorProto } from "google-protobuf/google/protobuf/descriptor_pb";

function mapProtoTypeToTs(protoType?: number): string {
  const typeMap: Record<number, string> = {
    1: "number", // TYPE_DOUBLE
    2: "number", // TYPE_FLOAT
    3: "number", // TYPE_INT64
    4: "number", // TYPE_UINT64
    5: "number", // TYPE_INT32
    6: "number", // TYPE_FIXED64
    7: "number", // TYPE_FIXED32
    8: "boolean", // TYPE_BOOL
    9: "string", // TYPE_STRING
    10: "Object", // TYPE_GROUP
    11: "string", // TYPE_MESSAGE
    12: "number", // TYPE_BYTES
    13: "number", // TYPE_UINT32
    14: "number", // TYPE_ENUM
    15: "number", // TYPE_SFIXED32
    16: "number", // TYPE_SFIXED64
    17: "number", // TYPE_SINT32
    18: "number", // TYPE_SINT64
  };
  return protoType ? typeMap[protoType] : "any";
}

function transformType(type?: string) {
  switch (type) {
    case ".google.protobuf.Empty":
      return "void";
    case ".google.protobuf.Int64Value":
      return "BigNumber";
    case ".aelf.Hash":
      return "string";
    case ".google.protobuf.BoolValue":
      return "boolean";
    case ".aelf.Address":
      return "string";
    case ".google.protobuf.Int32Value":
      return "number";
    default:
      return type?.slice(1) || "any";
  }
}

function generateServiceCode(fileDescriptor: FileDescriptorProto): string {
  let content =
    "// This file is generated by the protoc-gen-portkey-sdk-client-ts plugin.\n\n";

  // Generate imports and service definition
  content += `import { ContractBasic } from '@portkey/contracts';\n`;
  content += `import BigNumber from 'bignumber.js';\n`;

  fileDescriptor.getMessageTypeList().forEach((message) => {
    content += `export interface ${message.getName()} {\n`;
    message.getFieldList().forEach((field) => {
      const fieldType = mapProtoTypeToTs(field.getType());
      content += `  ${field.getName()}: ${fieldType};\n`;
    });
    content += "}\n\n";
  });

  for (const service of fileDescriptor.getServiceList()) {
    // Generate methods for the service
    for (const method of service.getMethodList()) {
      const inputType = transformType(method.getInputType()),
        outputType = transformType(method.getOutputType()),
        isGetMethod = method.getName()?.startsWith("Get"),
        withParams = `${inputType === "void" ? "" : `, params: ${inputType}`}`;

      if (isGetMethod) {
        content += `export function ${method.getName()}(contract: ContractBasic${withParams}) {
  return contract.callViewMethod<${outputType}>('${method.getName()}'${
          withParams ? ", params" : ""
        })
}\n`;
      } else {
        content += `export function ${method.getName()}(contract: ContractBasic, account: string${withParams}) {
  return contract.callSendMethod<${outputType}>('${method.getName()}', account${
          withParams ? ", params" : ""
        })
}\n`;
      }
    }
  }

  return content;
}

function generateTypeScriptCode(
  request: CodeGeneratorRequest
): CodeGeneratorResponse {
  const response = new CodeGeneratorResponse();

  // Process each FileDescriptorProto in the CodeGeneratorRequest
  for (const fileDescriptor of request.getProtoFileList()) {
    const content = generateServiceCode(fileDescriptor);
    const fileResponse = new CodeGeneratorResponse.File();
    fileResponse.setName(
      `${fileDescriptor.getName().replace(".proto", "")}_portkey_sdk_client.ts`
    );
    fileResponse.setContent(content);
    response.clearFileList();
    response.addFile(fileResponse);
  }

  return response;
}

function main() {
  const pluginRequest = fs.readFileSync(process.stdin.fd);
  const request = CodeGeneratorRequest.deserializeBinary(pluginRequest);
  const response = generateTypeScriptCode(request);

  const serializedResponse = response.serializeBinary();
  process.stdout.write(serializedResponse);
}

main();
